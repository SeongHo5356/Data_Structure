// Test driver#include <iostream>#include <fstream>#include "QueType.h"using namespace std;void ReplaceItem(QueType Que, int oldItem, int newItem);bool Identical(QueType queue1, QueType queue2);int main(){  ifstream inFile;       // file containing operations  ofstream outFile;      // file containing output  string inFileName;     // input file external name  string outFileName;    // output file external name  string outputLabel;       string command;        // operation to be executed    ItemType item;  QueType queue(5);  int numCommands;  // Prompt for file names, read file names, and prepare files  cout << "Enter name of input command file; press return." << endl;  cin  >> inFileName;  inFile.open(inFileName.c_str());  cout << "Enter name of output file; press return." << endl;  cin  >> outFileName;  outFile.open(outFileName.c_str());  cout << "Enter name of test run; press return." << endl;  cin  >> outputLabel;  outFile << outputLabel << endl;  inFile >> command;  numCommands = 0;  while (command != "Quit")  {     try     {      if (command == "Enqueue")      {        inFile >> item;         queue.Enqueue(item);        outFile << item << " is enqueued." << endl;      }      else if (command == "Dequeue")      {        queue.Dequeue(item);         outFile<< item  << " is dequeued. " << endl;      }       else if (command == "IsEmpty")         if (queue.IsEmpty())          outFile << "Queue is empty." << endl;        else           outFile << "Queue is not empty." << endl;                   else if (command == "IsFull")        if (queue.IsFull())          outFile << "Queue is full." << endl;        else outFile << "Queue is not full."  << endl;      }    catch (FullQueue)    {      outFile << "FullQueue exception thrown." << endl;    }        catch (EmptyQueue)    {      outFile << "EmtpyQueue exception thrown." << endl;    }        numCommands++;    cout <<  " Command number " << numCommands << " completed."          << endl;    inFile >> command;   };   cout << "Testing completed."  << endl;  inFile.close();  outFile.close();  return 0;}//client level ReplaceItem()void ReplaceItem(QueType Que, int oldItem, int newItem) {    int temp;    QueType MQue;    while (!Que.IsEmpty())    {        Que.Dequeue(temp);        if (temp == oldItem)        {            temp = newItem;        }        MQue.Enqueue(temp);    }    while (!MQue.IsEmpty())    {        MQue.Dequeue(temp);        Que.Enqueue(temp);    }}//client level Identical()bool Identical(QueType queue1, QueType queue2){    QueType temp1, temp2;    bool same = true;    int item1, item2;    while (!queue1.IsEmpty()) {        queue1.Dequeue(item1);         queue2.Dequeue(item2);             temp1.Enqueue(item1);        temp2.Enqueue(item2);        if (item1 != item2)        {            same = false;        }            }    // queue1,2 복구작업    while (!queue1.IsEmpty())    {        queue1.Dequeue(item1);        temp1.Enqueue(item1);    }    while (!queue2.IsEmpty()) {        queue2.Dequeue(item2);        temp2.Enqueue(item2);    }    // queue1,2 복구작업    while (!temp1.IsEmpty()) {        temp1.Dequeue(item1);        queue1.Enqueue(item1);    }    while (!temp2.IsEmpty()) {        temp2.Dequeue(item2);        queue2.Enqueue(item2);    }    if (queue2.IsEmpty() && same)    {        return true;    }    else     {        return false;    }}// client level Length()int Length(QueType queue) {    int count = 0; // queue의 길이를 잴 변수    int item;    QueType temp;    while (!queue.IsEmpty()) {        queue.Dequeue(item);        temp.Enqueue(item);        count++;    }    // queue 복구    while (!temp.IsEmpty()) {        temp.Dequeue(item);        queue.Enqueue(item);    }    return count;}